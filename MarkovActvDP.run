# Call solver and give it options

model "MarkovActvDP.mod";
data "MarkovActvDP.dat";

# Set at a trivial inistial value
let {(t,j) in X} EV[t,j] := initEV;

# Set at true values
let valueOfTime := trueValueOfTime;
let {j in ACTV} Um[j]:= trueUm[j];
let {j in ACTV}  b[j]:= trueB[j];
let {j in ACTV}  c[j]:= trueC[j];

# Fix the structural parameters at the true values
fix valueOfTime;
fix Um;
fix b;
fix c;

# Specify KNITRO solver options:
option solver knitroampl;
option knitro_options "alg=1 hessopt=1 outlev=3 maxit=500 xtol=0.0000000001 wantsol=1";

# Solve command
solve MarkovActvDP;

# Postprocess
if match (solve_message, "Locally optimal solution") > 0 then { 
	printf "%s\n", "Optimal solution found" > EV/MarkovActvSol.txt;
	printf "%5.0f \n", 0 > EV/KnitroExit.sol ; 
}
else if match (solve_message, "Iteration limit reached") > 0 then { 
	printf "%s\n", "Iteration limit reached" > EV/MarkovActvSol.txt;
	printf "%5.0f \n", 400 > EV/KnitroExit.sol ; 
}
else if match (solve_message, "Evaluation error") > 0 then { 
	printf "%s\n", "Evaluation error" > EV/MarkovActvSol.txt;
	printf "%5.0f \n", 502 > EV/KnitroExit.sol ; 
}
else {
	printf "%s\n", "No solution" > EV/MarkovActvSol.txt;
	printf "%5.0f \n", 1000 > EV/KnitroExit.sol ; 
}

display _solve_time;

# Output commands
option display_round 6, display_width 120;

# display the activity utility
# display actvUtil;
# display the value function
# display EV;
# display the choice-specific utility
# display choiceUtil;
# display the choice probability
# display choiceProb;

# display the structural parameters (remember beta was fixed)
display beta, valueOfTime, Um, b, c;

printf "%10.7f \n", _solve_time > EV/solvetime.sol;
printf "%10.7f \n", valueOfTime > EV/valueOfTime.sol;

# write EV to a file EUtil.m
printf "EV = [\n" > EV/EUtil.m;
for {t in TIME} {
	for {j in D} {
		printf "%10.7f\t", EV[t,j] > EV/EUtil.m;
	}
	printf "\n" > EV/EUtil.m;
}
printf "];" > EV/EUtil.m;

# write choiceProb to a file Prob.m
printf "Pr = zeros(%d, %d, %d);\n", H, M, M > EV/Prob.m;
for {j in D} {
	printf "Pr(:, %d, :) = [\n", j > EV/Prob.m;
	for {t in TIME} {
		for {k in D} {
			printf "%10.7f\t", choiceProb[t,j,k] > EV/Prob.m;
		}
		printf "\n" > EV/Prob.m;
	}
	printf "];\n" > EV/Prob.m;
}
