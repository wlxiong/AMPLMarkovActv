# Call solver and give it options

model "MarkovActvDP.mod";
data "MarkovActvDP.dat";
 
# Specify KNITRO solver options:

option knitro_options 'alg=1 outlev=3 maxit=500 xtol=0.0000000001', solver knitroampl;
 
# Initial guesses set at trivial values; probably not good initial guess
let {(t,j) in X} EV[t,j] := 0.0;
let valueOfTime := trueValueOfTime;
let {j in ACTV} U0[j]:= trueU0[j];
let {j in ACTV} Um[j]:= trueUm[j];
let {j in ACTV} gamma[j]:= trueGamma[j];
let {j in ACTV} xi[j]:= trueXi[j];

# Fix the structural parameters at the true values
fix valueOfTime;
fix U0;
fix Um;
fix gamma;
fix xi;

# Solve command
solve MarkovActv;

# Postprocess
if match (solve_message, "Locally optimal solution") > 0 then { 
	printf "%s\n", "Optimal solution found" > EV/MarkovActvSol.txt;
	printf "%5.0f \n", 0 > EV/KnitroExit.sol ; 
}
else if match (solve_message, "Iteration limit reached") > 0 then { 
	printf "%s\n", "Iteration limit reached" > EV/MarkovActvSol.txt;
	printf "%5.0f \n", 400 > EV/KnitroExit.sol ; 
}
else if match (solve_message, "Evaluation error") > 0 then { 
	printf "%s\n", "Evaluation error" > EV/MarkovActvSol.txt;
	printf "%5.0f \n", 502 > EV/KnitroExit.sol ; 
}
else {
	printf "%s\n", "No solution" > EV/MarkovActvSol.txt;
	printf "%5.0f \n", 1000 > EV/KnitroExit.sol ; 
}

display _solve_time;

# Output commands
option display_round 6, display_width 120;

# display the value function
display EV;

# display the structural parameters (remember beta was fixed)
display beta, valueOfTime, U0, Um, gamma, xi;

/*printf "%10.7f \n", _solve_time > EV/solvetime.sol;
#  printf "%10.7f \n", Likelihood > EV/objval.sol;     
printf "%10.7f \n", RC > EV/RC.sol;
printf "%10.7f \n", thetaCost > EV/thetCost.sol;
for {i in 1..M} {
  	printf "%10.7f \n", thetaProbs[i] > EV/thetaProbs.sol;
}
  # write EV to a file EV.sol 
for {i in X} {
  	printf "%10.7f \n", EV[i] > EV/EV.sol;
}
*/