# Call solver and give it options

# Load model and data
model "MarkovActv.mod"
data "MarkovActv.dat"

# include the simulated states and choices
data "DATA/MC.dat"

# Define the MLE problem
problem MarkovActvMLE:

# Choose the objective function
likelihood,

# List the variables
EV, actvUtil, choiceUtil, choiceProb, VoT, theta, Um, b, c,
# EV, actvUtil, choiceUtil, choiceProb, VoT, theta, Uw, xi, gamma,

# List the constraints
Bellman_Eqn,
Bellman_EqnH;

# include the code that define the state and choice set
include MarkovActv.run

# Set at a trivial initial value
let {t in 0..H, j in ACTV} EV[t,j] := initEV;

# Fix theta at the true value
fix theta := trueTheta;

# Initial guesses set at trivial values; probably not good initial guesses
fix VoT := trueVoT;

# Specify KNITRO solver options:
option solver "C:\Ziena\Knitro800\knitroampl\knitroampl.exe";
option knitro_options "alg=1 hessopt=1 bar_murule=0 ms_enable=1 ms_maxsolves=45 ms_maxbndrange=0 outlev=3 maxit=300 xtol=0.0000000001 wantsol=1";

# Output commands
option display_round 6, display_width 120;

let {j in ACTV} Um[j]:= initUm[j];
let {j in ACTV}  b[j]:= initB[j];
let {j in ACTV}  c[j]:= initC[j];

# Solve command
solve MarkovActvMLE;
display _solve_time;

# display estimates of structural parameters
display beta, theta, VoT;
display Um, b, c;
# display the true values
display trueUm, trueB, trueC;
# display Uw, xi, gamma, lambda;

# write the estimates
printf "param VoT_ := %f\n; ", VoT > DATA/MLE.dat;
printf "param Um_ := \n" > DATA/MLE.dat;
for {j in ACTV} {
	printf "%d\t%f\n", j, Um[j] > DATA/MLE.dat;
}
printf ";\n" > DATA/MLE.dat;
printf "param  b_ := \n" > DATA/MLE.dat;
for {j in ACTV} {
	printf "%d\t%f\n", j, b[j] > DATA/MLE.dat;
}
printf ";\n" > DATA/MLE.dat;
printf "param  c_ := \n" > DATA/MLE.dat;
for {j in ACTV} {
	printf "%d\t%f\n", j, c[j] > DATA/MLE.dat;
}
printf ";\n" > DATA/MLE.dat;

# export to MATLAB
printf "ml = %f;\n", likelihood > DATA/MLE.m;

# export fixed parameters to MLE.m
# printf "beta = %f;\n", beta > DATA/MLE.m;
# printf "theta = %f;\n", theta > DATA/MLE.m;

# export the estimated parameters to MLE.m
printf "VoT_ = %f;\n", VoT > DATA/MLE.m;
printf "Um_ = [ " > DATA/MLE.m;
for {j in ACTV} {
	printf "%f ", Um[j] > DATA/MLE.m;
}
printf "];\n" > DATA/MLE.m;
printf "b_ = [ " > DATA/MLE.m;
for {j in ACTV} {
	printf "%f ", b[j] > DATA/MLE.m;
}
printf "];\n" > DATA/MLE.m;
printf "c_ = [ " > DATA/MLE.m;
for {j in ACTV} {
	printf "%f ", c[j] > DATA/MLE.m;
}
printf "];\n" > DATA/MLE.m;

# display Uw, xi, gamma, lambda > DATA/MLE.sol;

# display the value function
# display EV;

# suppress the equilibrium constraints to 
# calculate the Hessian of objective only
fix EV;
drop Bellman_Eqn;
drop Bellman_EqnH;

# display solver's variables _svarname, _svar
display _svarname, _svar > DATA/SVAR.sol;

# calculate the Hessain matrix
option solver "C:\AMPLcml\gjh.exe";
option gjh_options "g=grad J=Jaco H=Hess";
write "bDATA/HES"; solve;
include DATA/HES.gjh;

# export the gradient vector
printf "\ngrad = [ " > DATA/MLE.m;
for {i in 1..9} {
	printf "%f ", grad[i] > DATA/MLE.m;
}
printf "];\n" > DATA/MLE.m;

# export the Hessian matrix
printf "Hess = [ \n" > DATA/MLE.m;
for {i in 1..9} {
	for {j in 1..9} {
		printf "%f ", Hess[i,j] > DATA/MLE.m;
	}
	printf "\n" > DATA/MLE.m;
}
printf "];\n" > DATA/MLE.m;
