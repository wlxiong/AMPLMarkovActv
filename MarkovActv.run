# Define the feasible states for each time slice
let isFeasibleState[H,HOME] := 1;	# initialize the terminal state
for {t in H-1..0 by -1, j in ACTV, k in ACTV} {
	if  t+travelTime[t,j,k]+1 >= opening[k]/T and 
		t+travelTime[t,j,k]+1 <= closing[k]/T and 
		t+travelTime[t,j,k]+1 <= H and 
		isFeasibleState[t+travelTime[t,j,k]+1, k] > 0
	then {
		let isFeasibleState[t,j] := 1;
		let isFeasibleChoice[t,j,k] := 1;
	};
}

# Write isFeasibleState to DATA/ISF.sol
for {t in 0..H} {
	for {j in ACTV}
		printf "%d\t", isFeasibleState[t,j] > DATA/ISF.sol;
	printf "\n" > DATA/ISF.sol;
}
