# Define the feasible states for each time slice
let isFeasibleState[H,HOME] := 1;	# initialize the terminal state
for {t in H-1..0 by -1, j in ACTV, k in ACTV} {
	if t < opening[j]/T or t > closing[j]/T then
		continue;
	if j == k then {
		for {h in TIME} {
			if t + 1 >= opening[k]/T and
			   t + h <= closing[k]/T and
			   t + h <= H and
			   isFeasibleState[t+h,k] > 0 then {
					let isFeasibleState[t,j] := 1;
					let isFeasibleChoice[t,j,k,h] := 1;
			};
		}
	} else {
		if t + travelTime[t,j,k] <= H and
		   isFeasibleState[t+travelTime[t,j,k],k] > 0 then {
				let isFeasibleState[t,j] := 1;
				let isFeasibleChoice[t,j,k,travelTime[t,j,k]] := 1;
		};
	};
}

# Write isFeasibleState to DATA/ISFS.sol
for {t in 0..H} {
	for {j in ACTV}
		printf "%d\t", isFeasibleState[t,j] > DATA/ISFS.sol;
	printf "\n" > DATA/ISFS.sol;
}

for {t in 0..H} {
	for {j in ACTV} {
		if (t,j) in X then { 
			printf "%d\t", card(DACTV[t,j]) > DATA/ISFD.sol;
		};
	}
	printf "\n" > DATA/ISFD.sol;
}
