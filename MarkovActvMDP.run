# Call solver and give it options

# TODO run simulation with estimated parameters

# Load model and data
model "MarkovActv.mod";
data "MarkovActv.dat";

# Define the MDP problem
problem MarkovActvMDP:

# Choose the objective function
likelihood0,

# List the variables
EV, actvUtil, choiceUtil, choiceProb, valueOfTime, theta, Um, b, c,
# EV, actvUtil, choiceUtil, choiceProb, valueOfTime, theta, Uw, xi, gamma,

# List the constraints
Bellman_Eqn,
EVBound;

# Set at a trivial inistial value
let {(t,j) in X} EV[t,j] := initEV;

# Set at true values
let valueOfTime := trueValueOfTime;
let theta := trueTheta;

let {j in ACTV} Um[j]:= trueUm[j];
let {j in ACTV}  b[j]:= trueB[j];
let {j in ACTV}  c[j]:= trueC[j];

# let {j in ACTV} Uw[j] := trueUw[j];
# let {j in ACTV} xi[j] := trueXi[j];
# let {j in ACTV} gamma[j] := trueGamma[j];
# let {j in ACTV} lambda[j] := trueLambda[j];

# Fix the structural parameters at the true values
fix valueOfTime;
fix theta;

fix Um;
fix b;
fix c;

# fix Uw;
# fix xi;
# fix gamma;
# fix lambda;

# Specify KNITRO solver options:
option solver knitroampl;
option knitro_options "alg=1 hessopt=1 outlev=3 maxit=500 xtol=0.0000000001 wantsol=1";

# Solve command
solve MarkovActvMDP;

# Solution status
if match (solve_message, "Locally optimal solution") > 0 then { 
	printf "%s\n", "Optimal solution found" > DATA/MDP.sol;
	printf "%5.0f \n", 0 > DATA/MDP.sol ; 
}
else if match (solve_message, "Iteration limit reached") > 0 then { 
	printf "%s\n", "Iteration limit reached" > DATA/MDP.sol;
	printf "%5.0f \n", 400 > DATA/MDP.sol ; 
}
else if match (solve_message, "Evaluation error") > 0 then { 
	printf "%s\n", "Evaluation error" > DATA/MDP.sol;
	printf "%5.0f \n", 502 > DATA/MDP.sol ; 
}
else {
	printf "%s\n", "No solution" > DATA/MDP.sol;
	printf "%5.0f \n", 1000 > DATA/MDP.sol ; 
}

display _solve_time;

# Output commands
option display_round 6, display_width 120;

# display the activity utility
# display actvUtil;
# display the value function
# display EV;
# display the choice-specific utility
# display choiceUtil;
# display the choice probability
# display choiceProb;

# display the structural parameters (remember beta was fixed)
display beta, valueOfTime, theta;
display Um, b, c;
# display Uw, xi, gamma, lambda;

printf "_solve_time:\t%10.7f \n", _solve_time > DATA/MDP.sol;

# write EV to a file EUtil.m
printf "EV = [\n" > DATA/EUtil.m;
for {t in TIME} {
	for {j in D} {
		printf "%10.7f\t", EV[t,j] > DATA/EUtil.m;
	}
	printf "\n" > DATA/EUtil.m;
}
printf "];" > DATA/EUtil.m;

# write choiceProb to a file Prob.m
printf "Pr = zeros(%d, %d, %d);\n", H, M, M > DATA/Prob.m;
for {j in D} {
	printf "Pr(:, %d, :) = [\n", j > DATA/Prob.m;
	for {t in TIME} {
		for {k in D} {
			printf "%10.7f\t", choiceProb[t,j,k] > DATA/Prob.m;
		}
		printf "\n" > DATA/Prob.m;
	}
	printf "];\n" > DATA/Prob.m;
}
