# Call solver and give it options

# TODO run simulation with estimated parameters

# Load model and data
model "MarkovActv.mod";
data "MarkovActv.dat";

# Define the MDP problem
problem MarkovActvMDP:

# Choose the objective function
likelihood0,

# List the variables
EV, actvUtil, choiceUtil, choiceProb, VoT, theta, Um, b, c,
# EV, actvUtil, choiceUtil, choiceProb, VoT, theta, Uw, xi, gamma,

# List the constraints
Bellman_Eqn,
Bellman_EqnH;

# include the code that define the state and choice set
include MarkovActv.run;

# Set at a trivial initial value
let {t in 0..H, j in ACTV} EV[t,j] := initEV;

# Fix at true values
fix VoT := trueVoT;

fix {j in ACTV} Um[j]:= trueUm[j];
fix {j in ACTV}  b[j]:= trueB[j];
fix {j in ACTV}  c[j]:= trueC[j];

# fix {j in ACTV} Uw[j] := trueUw[j];
# fix {j in ACTV} xi[j] := trueXi[j];
# fix {j in ACTV} gamma[j] := trueGamma[j];
# fix {j in ACTV} lambda[j] := trueLambda[j];

# Fix theta at the true value
fix theta := trueTheta;

# Specify KNITRO solver options:
option knitro_options "alg=2 hessopt=2 outlev=3 maxit=100 xtol=0.0000000001 wantsol=1";

# Solve command
solve MarkovActvMDP;

# Solution status
print "DATA/MDP.sol";
print "------------";
if match (solve_message, "Locally optimal solution") > 0 then { 
	printf "%s\n", "Optimal solution found";
	printf "%5.0f \n", 0;
}
else if match (solve_message, "Iteration limit reached") > 0 then { 
	printf "%s\n", "Iteration limit reached";
	printf "%5.0f \n", 400;
}
else if match (solve_message, "Evaluation error") > 0 then { 
	printf "%s\n", "Evaluation error";
	printf "%5.0f \n", 502;
}
else {
	printf "%s\n", "No solution";
	printf "%5.0f \n", 1000;
}

printf "_solve_time:\t%10.7f \n", _solve_time;

display _solve_time;

# Output commands
option display_round 6, display_width 120;

# display the activity utility
# display actvUtil;
# display the value function
# display EV;
# display the choice-specific utility
# display choiceUtil;
# display the choice probability
# display choiceProb;

# display the structural parameters (all were fixed)
display beta, VoT, theta;
display Um, b, c;
# display Uw, xi, gamma, lambda;

# write EV to a file EUtil.m
print "DATA/EUtil.m";
print "------------";
printf "EV = [\n";
for {t in TIME} {
	for {j in ACTV} {
		if (t,j) in X then
			printf "%10.7f\t", EV[t,j];
		else
			printf "%10.7f\t", -1;
	}
	printf "\n";
}
printf "];\n";

# write choiceProb to a file Prob.m
print "DATA/Prob.m";
print "-----------";
printf "Pr = zeros(%d, %d, %d);\n", H, M, M;
for {j in ACTV} {
	printf "Pr(:, %d, :) = [\n", j;
	for {t in TIME} {
		if (t,j) in X then
			for {k in ACTV} {
				if k in D[t,j] then
					printf "%10.7f\t", choiceProb[t,j,k];
				else
					printf "%10.7f\t", 0.0;
			}
		else
			for {k in ACTV} {
				printf "%10.7f\t", 0.0;
			}
		printf "\n";
	}
	printf "];\n";
}

# export fixed parameters to MDP.m
print "DATA/MDP.m";
print "----------";
printf "beta = %f;\n", beta;
printf "theta = %f;\n", theta;
# export the structural parameters to MDP.m
printf "VoT0 = %f;\n", VoT;
printf "Um0 = [ ";
for {j in ACTV} {
	printf "%f ", Um[j];
}
printf "];\n";
printf "b0 = [ ";
for {j in ACTV} {
	printf "%f ", b[j];
}
printf "];\n";
printf "c0 = [ ";
for {j in ACTV} {
	printf "%f ", c[j];
}
printf "];\n";
