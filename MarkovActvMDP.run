# Call solver and give it options

# TODO run simulation with estimated parameters

# Load model and data
model "MarkovActv.mod";
data "MarkovActv.dat";

# Define the MDP problem
problem MarkovActvMDP:

# Choose the objective function
likelihood0,

# List the variables
EV, actvUtil, choiceUtil, choiceProb, VoT, theta, Um, b, c,
# EV, actvUtil, choiceUtil, choiceProb, VoT, theta, Uw, xi, gamma,

# List the constraints
Bellman_Eqn,
Bellman_EqnH,
EVBound;

# include the code that define the state and choice set
include MarkovActv.run

# Set at a trivial initial value
let {t in 0..H, j in ACTV} EV[t,j] := initEV;

# Fix at true values
fix VoT := trueVoT;

fix {j in ACTV} Um[j]:= trueUm[j];
fix {j in ACTV}  b[j]:= trueB[j];
fix {j in ACTV}  c[j]:= trueC[j];

# fix {j in ACTV} Uw[j] := trueUw[j];
# fix {j in ACTV} xi[j] := trueXi[j];
# fix {j in ACTV} gamma[j] := trueGamma[j];
# fix {j in ACTV} lambda[j] := trueLambda[j];

# Fix theta at the true value
fix theta := trueTheta;

# Specify KNITRO solver options:
option solver "C:\Ziena\Knitro800\knitroampl\knitroampl.exe";
option knitro_options "alg=2 hessopt=2 outlev=3 maxit=100 xtol=0.0000000001 wantsol=1";

# Solve command
solve MarkovActvMDP;

# Solution status
if match (solve_message, "Locally optimal solution") > 0 then { 
	printf "%s\n", "Optimal solution found" > DATA/MDP.sol;
	printf "%5.0f \n", 0 > DATA/MDP.sol ; 
}
else if match (solve_message, "Iteration limit reached") > 0 then { 
	printf "%s\n", "Iteration limit reached" > DATA/MDP.sol;
	printf "%5.0f \n", 400 > DATA/MDP.sol ; 
}
else if match (solve_message, "Evaluation error") > 0 then { 
	printf "%s\n", "Evaluation error" > DATA/MDP.sol;
	printf "%5.0f \n", 502 > DATA/MDP.sol ; 
}
else {
	printf "%s\n", "No solution" > DATA/MDP.sol;
	printf "%5.0f \n", 1000 > DATA/MDP.sol ; 
}

display _solve_time;

# Output commands
option display_round 6, display_width 120;

# display the activity utility
# display actvUtil;
# display the value function
# display EV;
# display the choice-specific utility
# display choiceUtil;
# display the choice probability
# display choiceProb;

# display the structural parameters (remember beta was fixed)
display beta, VoT, theta;
display Um, b, c;
# display Uw, xi, gamma, lambda;

printf "_solve_time:\t%10.7f \n", _solve_time > DATA/MDP.sol;

# write EV to a file EUtil.m
printf "EV = [\n" > DATA/EUtil.m;
for {t in TIME} {
	for {j in ACTV} {
		if (t,j) in X then
			printf "%10.7f\t", EV[t,j] > DATA/EUtil.m;
		else
			printf "%10.7f\t", -1 > DATA/EUtil.m;
	}
	printf "\n" > DATA/EUtil.m;
}
printf "];" > DATA/EUtil.m;

# write choiceProb to a file Prob.m
printf "Pr = zeros(%d, %d, %d);\n", H, M, M > DATA/Prob.m;
for {j in ACTV} {
	printf "Pr(:, %d, :) = [\n", j > DATA/Prob.m;
	for {t in TIME} {
		if (t,j) in X then
			for {k in ACTV} {
				if k in D[t,j] then
					printf "%10.7f\t", choiceProb[t,j,k] > DATA/Prob.m;
				else
					printf "%10.7f\t", 0.0 > DATA/Prob.m;
			}
		else
			for {k in ACTV} {
				printf "%10.7f\t", 0.0 > DATA/Prob.m;
			}
		printf "\n" > DATA/Prob.m;
	}
	printf "];\n" > DATA/Prob.m;
}
